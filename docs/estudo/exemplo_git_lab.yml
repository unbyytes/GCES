# Define os estágios (etapas) do pipeline, na ordem de execução.
stages:
  - setup
  - test
  - build
  - deploy_staging
  - deploy_production

# Define um cache global para acelerar a instalação de dependências.
# A chave "default" garante que o cache seja compartilhado entre todas as branches.
cache:
  key:
    files:
      - backend/requirements.txt
      - frontend/package-lock.json
  paths:
    - .cache/pip
    - frontend/node_modules/
  policy: pull-push

# =================================================================
# STAGE: SETUP
# =================================================================

install_dependencies:
  stage: setup
  image: node:18-alpine # Imagem leve com Node.js e Python pré-instalados
  script:
    - echo "Instalando dependências do Backend..."
    - pip install --cache-dir .cache/pip -r backend/requirements.txt
    - echo "Instalando dependências do Frontend..."
    - cd frontend && npm install
  # Este job atualiza o cache, os demais jobs (policy: pull) apenas o consomem.
  cache:
    <<: *cache # Reutiliza a definição de cache global
    policy: pull-push

# =================================================================
# STAGE: TEST
# =================================================================

backend_test:
  stage: test
  image: python:3.9-slim
  needs: [install_dependencies] # Garante que as dependências já foram instaladas
  script:
    - echo "Executando testes do Backend com Pytest..."
    - pip install --cache-dir .cache/pip -r backend/requirements.txt
    - cd backend
    - pytest --junitxml=report.xml # Gera um relatório de testes
  artifacts:
    when: always # Salva o artefato mesmo se o job falhar
    paths:
      - backend/report.xml
    expire_in: 1 week # O relatório ficará disponível por uma semana

frontend_lint_test:
  stage: test
  image: node:18-alpine
  needs: [install_dependencies]
  script:
    - echo "Executando linter e testes do Frontend..."
    - cd frontend
    - npm test
  # Opcional: se o seu teste gera um relatório de cobertura, salve-o como artefato.
  # artifacts:
  #   paths:
  #     - frontend/coverage/

# =================================================================
# STAGE: BUILD
# =================================================================

build_docker_images:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind # Docker-in-Docker para construir imagens
  needs: [backend_test, frontend_lint_test] # Só constrói se os testes passarem
  before_script:
    # $CI_REGISTRY_USER, $CI_REGISTRY_PASSWORD e $CI_REGISTRY são variáveis pré-definidas pelo GitLab
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  script:
    - echo "Construindo e enviando a imagem do Backend..."
    # Usa a tag do commit para versionar a imagem
    - docker build -t "$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHORT_SHA" ./backend
    - docker push "$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHORT_SHA"

    - echo "Construindo e enviando a imagem do Frontend..."
    - docker build -t "$CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHORT_SHA" ./frontend
    - docker push "$CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHORT_SHA"
  rules:
    # Este job só executa na branch 'main' ou 'develop'
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "develop"'

# =================================================================
# STAGE: DEPLOY
# =================================================================

deploy_to_staging:
  stage: deploy_staging
  image: alpine:latest # Imagem mínima, pois só usaremos SSH
  needs: [build_docker_images]
  before_script:
    - 'which ssh-agent || ( apk add --update openssh )'
    - eval $(ssh-agent -s)
    # Adiciona a chave SSH (armazenada em uma variável de ambiente) ao agente
    - echo "$STAGING_SSH_PRIVATE_KEY" | ssh-add -
    - mkdir -p ~/.ssh
    - '[[ -f /.dockerenv ]] && echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config'
  script:
    - echo "Fazendo deploy no ambiente de Staging (Homologação)..."
    - >
      ssh $STAGING_SSH_USER@$STAGING_SERVER_IP "
      cd /home/user/ej-platform &&
      export BACKEND_IMAGE=$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHORT_SHA &&
      export FRONTEND_IMAGE=$CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHORT_SHA &&
      docker-compose pull &&
      docker-compose up -d --force-recreate
      "
  environment:
    name: staging
    url: http://staging.ejplatform.org # URL do ambiente para acesso rápido no GitLab
  rules:
    # Este job só executa na branch 'develop'
    - if: '$CI_COMMIT_BRANCH == "develop"'

deploy_to_production:
  stage: deploy_production
  image: alpine:latest
  needs: [build_docker_images]
  before_script:
    - 'which ssh-agent || ( apk add --update openssh )'
    - eval $(ssh-agent -s)
    - echo "$PROD_SSH_PRIVATE_KEY" | ssh-add -
    - mkdir -p ~/.ssh
    - '[[ -f /.dockerenv ]] && echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config'
  script:
    - echo "Fazendo deploy no ambiente de Produção..."
    - >
      ssh $PROD_SSH_USER@$PROD_SERVER_IP "
      cd /home/user/ej-platform &&
      export BACKEND_IMAGE=$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHORT_SHA &&
      export FRONTEND_IMAGE=$CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHORT_SHA &&
      docker-compose pull &&
      docker-compose up -d --force-recreate
      "
  environment:
    name: production
    url: https://app.ejplatform.org
  rules:
    # Este job só executa na branch 'main' e PRECISA de aprovação manual para rodar.
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual # Ponto-chave para segurança em produção!